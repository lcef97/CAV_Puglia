---
title: "Investigating access to support centers for Violence Against Women in Apulia"
subtitle: "A spatial analysis over multiple years"
author: "Leonardo Cefalo (UniBA), Alessio Pollice (UniBA),
         Crescenza Calculli (UniBA) and Diego Battagliese (UniBA)"
date: "2025-09-19"
output:
  ioslides_presentation:
    css: style.css
    slide_level: 2
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning= FALSE, message = FALSE)
par(mar = c(2,2,1,1))
library(magrittr)
library(sf)
library(INLA)
#' Important:
#' switch to FALSE to run models in real-time. 
import_workspace <- TRUE

```

## Scope

  - Modelling the spatial variability and the association with candidate driving factors
  in the reporting of violence against women (VAW)
  - Variable of interest: counts of accesses to Anti-Violence Centers (AVCs) in Apulia
  per residence municipality of victims
  - Observation period: 2021 -- 2024; observation units: Apulian municipalities.
  - [Online version (**recursive**)](https://lcef97.github.io/CAV_Puglia/#1); more details [here](https://github.com/lcef97/CAV_Puglia/blob/main/CAV_panel.pdf)
  
## Importance of AVCs

  - Offering shelter, legal assistance and psycological support to women victims of gender-based violence
  - Maintaining systematic records of reported cases, as outlined in Italian Law no.119/2013
  - Data collected by the Statistical Section and the Welfare Department of the Apulia Region, as part of a systematic monitoring program established under Regional Law no. 29/2014

```{r InputMute,  echo = FALSE, message = FALSE, warning = FALSE, output = FALSE}
##' !!!!!!!!   BY ANY MEANS, do not touch the following anchoring line  !!!!!!!!
##' StartRemoteSource
## Input ----------------------------------------------------------------------#

load("../input/CAV_input_mun_2021.RData")
load("../input/CAV_input_mun_2022.RData")
load("../input/CAV_input_mun_2023.RData")
load("../input/CAV_input_mun_2024.RData")

source("../Auxiliary/Functions.R")

CAV_mun_21 <- CAV_mun_21 %>% dplyr::rename(N_ACC_2021 = .data$N_ACC)
CAV_mun_22 <- CAV_mun_22 %>% dplyr::rename(N_ACC_2022 = .data$N_ACC)
CAV_mun_23 <- CAV_mun_23 %>% dplyr::rename(N_ACC_2023 = .data$N_ACC)
CAV_mun_24 <- CAV_mun_24 %>% dplyr::rename(N_ACC_2024 = .data$N_ACC)

load("../input/Shp.RData")

#'  Function to extract numeric digits from a strings vector (needed to filter age):
nn_extract <- function(string){
  nn <- gregexpr("([0-9])", string)
  ls.out <- regmatches(as.list(string), nn)
  res <- unlist(lapply(ls.out, function(x) as.numeric(paste(x, collapse = ""))))  
  return(res)
}

Popolazione_Puglia_2021 <- readr::read_csv("../input/Popolazione_Puglia_2021.csv") %>% 
  dplyr::select(.data$ITTER107, .data$Territorio, .data$SEXISTAT1, .data$ETA1, .data$Value) %>% 
  dplyr::filter(.data$ETA1 != "TOTAL") %>% 
  dplyr::mutate(ETA1 = nn_extract(.data$ETA1)) %>% 
  dplyr::mutate(ITTER107 = as.numeric(.data$ITTER107))

Popolazione_Puglia_2022 <- readr::read_csv("../input/Popolazione_Puglia_2022.csv") %>% 
  dplyr::select(.data$ITTER107, .data$Territorio, .data$SEXISTAT1, .data$ETA1, .data$Value) %>% 
  dplyr::filter(.data$ETA1 != "TOTAL") %>% 
  dplyr::mutate(ETA1 = nn_extract(.data$ETA1)) %>% 
  dplyr::mutate(ITTER107 = as.numeric(.data$ITTER107))

Popolazione_Puglia_2023 <- readr::read_csv("../input/Popolazione_Puglia_2023.csv") %>% 
  dplyr::select(.data$ITTER107, .data$Territorio, .data$SEXISTAT1, .data$ETA1, .data$Value) %>% 
  dplyr::filter(.data$ETA1 != "TOTAL") %>% 
  dplyr::mutate(ETA1 = nn_extract(.data$ETA1)) %>% 
  dplyr::mutate(ITTER107 = as.numeric(.data$ITTER107))

Popolazione_Puglia_2024 <- readr::read_csv("../input/Popolazione_Puglia_2024.csv",
                                           quote = "")  %>% 
  dplyr::filter(.data$AGE != "TOTAL") %>% 
  dplyr::mutate(ETA1 = nn_extract(.data$AGE)) %>% 
  dplyr::mutate(ITTER107 = as.numeric(.data$REF_AREA)) %>% 
  dplyr::rename(SEXISTAT1 = .data$SEX, Value = .data$Osservazione)%>% 
  dplyr::select(.data$ITTER107, .data$SEXISTAT1, .data$ETA1, .data$Value)


Pop_f_15 <- Popolazione_Puglia_2021 %>% 
  dplyr::left_join(Popolazione_Puglia_2022,
                   by = c("ITTER107", "Territorio", "SEXISTAT1", "ETA1")) %>% 
  dplyr::left_join(Popolazione_Puglia_2023,
                   by = c("ITTER107", "Territorio", "SEXISTAT1", "ETA1")) %>% 
  dplyr::left_join(Popolazione_Puglia_2024,
                   by =  c("ITTER107",  "SEXISTAT1", "ETA1"))

names(Pop_f_15) <-  c("PRO_COM", "Comune", "Sesso", "Eta", 
                      "Popolazione_21", "Popolazione_22", "Popolazione_23", "Popolazione_24")

Pop_f_15 <- Pop_f_15 %>% dplyr::filter(.data$Sesso == 2) %>% 
  dplyr::filter(.data$Eta > 14) %>% 
  dplyr::group_by(.data$PRO_COM, .data$Comune) %>% 
  dplyr::summarise(nn_2021 = sum(.data$Popolazione_21),
                   nn_2022 = sum(.data$Popolazione_22),
                   nn_2023 = sum(.data$Popolazione_23),
                   nn_2024 = sum(.data$Popolazione_24)) %>%
  dplyr::ungroup()


# Tremiti Islands are a singleton --> need to remove them to perform spatial analysis
suppressWarnings({
  singletons <- Shp$PRO_COM[which(
    unlist(lapply(spdep::poly2nb(Shp),
                  function(x) x[1L] == 0)))]
})

load("../input/dists_th_22.RData")
load("../input/dists_th_23.RData")
load("../input/dists_th_24.RData")
names(dists_th_22)[2] <- names(dists_th_23)[2] <- names(dists_th_24)[2] <- "TEP_th"
distances <- rbind(dists_th_22, dists_th_22, dists_th_23, dists_th_24) %>% 
  dplyr::mutate(Year = c(rep(2021, nrow(dists_th_22)),
                         rep(2022, nrow(dists_th_22)),
                         rep(2023, nrow(dists_th_23)),
                         rep(2024, nrow(dists_th_24))) )


Shp_con <- dplyr::filter(Shp, !.data$PRO_COM %in% singletons)
n <- nrow(Shp_con)


dd <- Shp_con %>% dplyr::left_join(Pop_f_15[, -2], by = "PRO_COM") %>% 
  dplyr::left_join(dplyr::select(CAV_mun_21, -.data$comune),by = "PRO_COM") %>% 
  dplyr::left_join(dplyr::select(CAV_mun_22, -.data$comune),by = "PRO_COM") %>% 
  dplyr::left_join(dplyr::select(CAV_mun_23, -.data$comune),by = "PRO_COM") %>% 
  dplyr::left_join(dplyr::select(CAV_mun_24, -.data$comune),by = "PRO_COM") %>% 
  tidyr::pivot_longer(cols = tidyselect::starts_with("nn_") | 
                        tidyselect::starts_with("N_ACC_"),
                      names_to = c(".value", "Year"),
                      names_pattern = "(nn|N_ACC)_(\\d+)" ) %>% 
  dplyr::mutate(Year=as.numeric(.data$Year)) %>% 
  dplyr::left_join(dplyr::select(Indicators, -.data$Comune), by = "PRO_COM") %>% 
  dplyr::arrange(.data$Year, .data$PRO_COM)  %>% 
  dplyr::left_join(distances, by = c("PRO_COM", "Year")) %>% 
  dplyr::mutate(CAV = as.numeric(.data$TEP_th == 0)) %>% 
  dplyr::mutate(Y_2021 = as.numeric(.data$Year == 2021)) %>% 
  dplyr::mutate(Y_2022 = as.numeric(.data$Year == 2022)) %>% 
  dplyr::mutate(Y_2023 = as.numeric(.data$Year == 2023)) %>% 
  dplyr::mutate(Y_2024 = as.numeric(.data$Year == 2024)) %>% 
  dplyr::mutate(TEP_th = as.vector(scale(.data$TEP_th))) %>% 
  dplyr::mutate(AES = as.vector(scale(.data$AES))) %>% 
  dplyr::mutate(MFI = as.vector(scale(.data$MFI)))  %>% 
  dplyr::mutate(PDI = as.vector(scale(.data$PDI)))  %>% 
  dplyr::mutate(ELL = as.vector(scale(.data$ELL)))  %>% 
  dplyr::mutate(ER = as.vector(scale(.data$ER)))  %>% 
  dplyr::mutate(PGR = as.vector(scale(.data$PGR)))  %>% 
  dplyr::mutate(UIS = as.vector(scale(.data$UIS)))  %>% 
  dplyr::mutate(ELI = as.vector(scale(.data$ELI)))  %>% 
  #dplyr::select(-.data$Year) %>% 
  dplyr::mutate(ID = c(1:nrow(.))) %>% 
  dplyr::mutate(Area = as.numeric(as.factor(.data$PRO_COM)))



# Municipalities from which no woman reported violence --> count == 0
dd$N_ACC[is.na(dd$N_ACC)] <- 0

# "access ratio"
dd$LN_ACC <- log(dd$N_ACC/dd$nn)

#' neighbours list ------------------------------------------------------------#
nb_con <- spdep::poly2nb(dd[c(1:n), ])

#' neighbouring/adjacency matrix ----------------------------------------------#
W_con <- spdep::nb2mat(nb_con, style = "B")
rownames(W_con) <- colnames(W_con) <- dd$PRO_COM[c(1:n)]

#' Laplacian matrix -----------------------------------------------------------#
D_con <- Matrix::Diagonal(x=apply(W_con, MARGIN=1, FUN=function(x) sum(x)), n=n)
Lapl_con <- D_con - W_con
V_con <- eigen(Lapl_con)$vectors

constr <- INLA:::inla.bym.constr.internal(
  Q = Lapl_con, adjust.for.con.comp = T)
A_constr <- kronecker(Matrix::Diagonal(n=4,x=1), constr$constr$A)

#'  Necessary to constrain the BYM model --------------------------------------#
constr.BYM <- list(
  A = cbind(Matrix::Matrix(0, nrow = nrow(A_constr), ncol = ncol(A_constr)), A_constr),
  e=c(0,0,0,0) )


zhat_plot <- function(mod){
  n <- nrow(mod$.args$data)
  rr <- range(mod$summary.random$ID$mean[c(1:n)])
  
  plot_map <- purrr::map(unique(dd$Year), function (t){
    dd %>% dplyr::mutate(zhat = mod$summary.random$ID$mean[c(1:n)]) %>% 
      dplyr::filter(as.numeric(.data$Year) == t) %>% 
      ggplot2::ggplot() +
      ggplot2::geom_sf(ggplot2::aes(fill = .data$zhat))+
      ggplot2::labs(title = paste("Year:", t), 
                    fill = expression(E * "[" * z * "]")) +
      ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
      ggplot2::theme_classic()
  })
  
  do.call(gridExtra::grid.arrange, c(plot_map, nrow = 2, ncol = 2))
  
}

yhat_plot <- function(mod ){
  
  yhat <- round(mod$summary.fitted.values$mean, 0)
  
  rr <- c(0, max(yhat))
  
  plot_map <- purrr::map(unique(dd$Year), function (t){
    dd %>% dplyr::mutate(yhat = yhat) %>% 
      dplyr::filter(as.numeric(.data$Year) == t) %>% 
      ggplot2::ggplot() +
      ggplot2::geom_sf(ggplot2::aes(fill = .data$yhat)) +
      ggplot2::labs(title = paste("Year:", t), 
                    fill = expression(E * "[" * hat(y) * "]") )+
      ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
      ggplot2::theme_classic()
  })
  do.call(gridExtra::grid.arrange, c(plot_map, nrow = 2, ncol = 2))
}

etahat_plot <- function(mod, predictor = FALSE){
  
  etahat <- mod$summary.linear.predictor$mean
  
  rr <- range(etahat)
  
  plot_map <- purrr::map(unique(dd$Year), function (t){
    dd %>% 
      dplyr::mutate(etahat = etahat) %>% 
      dplyr::filter(as.numeric(.data$Year) == t) %>% 
      ggplot2::ggplot() +
      ggplot2::geom_sf(ggplot2::aes(fill =  .data$etahat )) +
      ggplot2::labs(title = paste("Year:", 2020+ t),
                    fill = expression(E * "[" * eta * "]")) + 
      ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
      ggplot2::theme_classic()
  })
  
  do.call(gridExtra::grid.arrange, c(plot_map, nrow = 2, ncol = 2))
  
}
##' !!!!!!!!   BY ANY MEANS, do not touch the following anchoring line  !!!!!!!!
##' EndRemoteSource

```

## Access to AVCs in Apulia: Incidence (1)

```{r Log accesses plot input,  echo = FALSE, warning = FALSE, message = FALSE  }


ggy21 <- ggplot2::ggplot() +
  ggplot2::geom_sf(data = dplyr::filter(dd, .data$Y_2021 == 1), 
                   ggplot2::aes(fill = .data$LN_ACC))+
  ggplot2::labs(fill = "Log-accesses, 2021")+
  ggplot2::scale_fill_viridis_c(na.value = "white",
                                direction = -1,
                                limits = c(-9.5, -4.5))+
  ggplot2::theme_classic()

ggy22 <- ggplot2::ggplot() +
  ggplot2::geom_sf(data = dplyr::filter(dd, .data$Y_2022 == 1), 
                   ggplot2::aes(fill = .data$LN_ACC))+
  ggplot2::labs(fill = "Log-accesses, 2022")+
  ggplot2::scale_fill_viridis_c(na.value = "white",
                                direction = -1,
                                limits = c(-9.5, -4.5))+
  ggplot2::theme_classic()

ggy23 <- ggplot2::ggplot() +
  ggplot2::geom_sf(data = dplyr::filter(dd, .data$Y_2023 == 1), 
                   ggplot2::aes(fill = .data$LN_ACC))+
  ggplot2::labs(fill = "Log-accesses, 2023")+
  ggplot2::scale_fill_viridis_c(na.value = "white",
                                direction = -1,
                                limits = c(-9.5, -4.5))+
  ggplot2::theme_classic()

ggy24 <- ggplot2::ggplot() +
  ggplot2::geom_sf(data = dplyr::filter(dd, .data$Y_2024 == 1), 
                   ggplot2::aes(fill = .data$LN_ACC))+
  ggplot2::labs(fill = "Log-accesses, 2024")+
  ggplot2::scale_fill_viridis_c(na.value = "white",
                                direction = -1,
                                limits = c(-9.5, -4.5))+
  ggplot2::theme_classic()


```

```{r Log accesses plot first, echo = FALSE, warning = FALSE, message = FALSE, fig.cap = "Log-access rate, 2021-2022" }

gridExtra::grid.arrange(ggy21, ggy22, nrow = 2)

```


## Access to AVCs in Apulia: Incidence (2)

```{r Log accesses plot second, echo = FALSE, warning = FALSE, message = FALSE, fig.cap = "Log-access rate, 2023-2024" }

gridExtra::grid.arrange(ggy23, ggy24, nrow = 2)

```


## Explanatory variables

 - **Distance** (`TEP`) from the **closest municipality** hosting an AVC (**MFI, 2021**), 

 - Components of the **Municipality Frailty Index** or MFI, 2021; source: [ISTAT](https://www.istat.it/comunicato-stampa/indice-di-fragilita-comunale-ifc/)
 

<div class="scroll-table">

<table>
  <thead>
    <tr>
      <th>Variable</th>
      <th>Unit</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>TEP</td><td>Minutes</td><td>Road **travel time** to the **closest** municipality hosting an AVC</td></tr>
    <tr><td>ELI</td><td>Ventile</td><td>Share of employees in **low productivity** units</td></tr>
    <tr><td>PGR</td><td>Rate</td><td>**Population growth** rate 2011–2021</td></tr>
    <tr><td>UIS</td><td>Ventile</td><td>**Density** of **economic** production units</td></tr>
    <tr><td>ELL</td><td>Percentage</td><td>Population aged [25–64] with **low education** level</td></tr>
    <tr><td>PDI</td><td>Percentage</td><td>**Structural dependency** index (population aged [0–19] or >64 over [20–64])</td></tr>
    <tr><td>ER</td><td>Percentage</td><td>**Employment rate** among population aged [20–64]</td></tr>
  </tbody>
</table>

</div>



## Regression model

  - **256** municipalities; **4** years
  
  - Standard **Poisson** linear regression: for $i \in [1,256]$, and $t \in \lbrace 2021, ..., 2024 \rbrace$ we have
  
$$
y_{it}\mid \eta_{it}, \theta \sim \mathrm{Poisson} \left(
\mathrm{E}_{it} \, e^{\eta_{it}} \right)
$$
  
  
  - Where 
    - $y_{it}$: AVC accesses in municipality $i$ and year $t$;
    
    -  $\mathrm{E}_{it}$: female population aged $>14$ years (offset)
    
    -  $\eta_{it}$: linear predictor; $\theta$: model hyperparameters
  
## The linear predictor

  - Inclusion of a multivariate latent **spatial** effect in $\eta$ to account for **territorial variability** and **overdispersion**
  
$$\eta_{it} := X_{it}^\top \beta + Z_{it}$$
  - $X$: Covariates; $\beta$: covariate effects
  
  - $Z_{it}$: multivariate latent spatial effect of size $n \times k$, where $n=256$ and $k=4$ \longrightarrow$ modelled via the flexible **M-Models** [@Mmodels]
    - Competing models: ICAR, PCAR, LCAR and BYM

## Models (1): Intrinsic CAR

  - Simplest formulation among spatial autoregressive models

$$
Z \mid \Sigma \sim \mathcal{N}_{kn} \left( 0, \Sigma \otimes (D - W)^{+} \right)
$$
  - $\Sigma$: $4 \times 4$ between-fields variance-covariance matrix
    
  - $D$: Graph **degree** matrix;
    
  - $W$: Graph **neighbourhood** matrix 
  
 $+$ Easy to **fit** and **interpret**
  
 $-$ implicitly assumes **spatial autocorrelation** equal to 1 $\rightarrow$ sometimes too **smooth** to adequately fit data
  
```{r IMCAR  }
if(import_workspace){
  load("WS/cav_IMCAR_inla.RData")
} else {
  
cav_IMCAR_inla <- inla(
  N_ACC ~ 0 + Y_2021 + Y_2022 + Y_2023 + Y_2024 +
    TEP_th + ELI + PGR + UIS + ELL + PDI + ER+ 
    f(ID, model = inla.IMCAR.Bartlett(k = 4, W = W_con, df = 8), 
      extraconstr = list(A = A_constr, e = c(0,0,0,0))),
  offset = log(nn), family = "poisson", data =dd,
  num.threads = 1, control.compute = list(internal.opt = F, cpo = T, waic = T, config = T), 
  verbose = F)

}

```

  
## M-models (I)

  - Based on the **decomposition** of the **scale parameter** as
  $\Sigma := M^\top M$
  
  - $M$: generic **full** rank matrix, in our application of size $k \times k$
    
  - consider $Z$ as a **combination** of $k$ independent fields $Z_j^{(0)}$ for $1 \leq j \leq k$, i.e. $Z :=  \left(Z_1^{(0)}, \dots,  Z_k^{(0)}\right) M$ 
  
  - $Z^{(0)} \sim \mathcal{N}_n \left( 0, \Omega_j \right)$ for a $n \times n$ s.p.d. matrix $\Omega_j$ depending:
  
    - On the **graph** structure
    
    - On an array of model-specific parameters 

## M-models (II) 
  
  Joint prior of $Z$:
  
  $$
  Z \sim \mathcal{N}_{nk} \left(0, 
  (M^\top\otimes I_n)\, \Omega \,
  (M \otimes I_n)
  \right)
  $$
  Where $\Omega$ is block-diagonal: 
  $$ \Omega = 
  \begin{pmatrix}
  \Omega_1 & 0 & \dots & 0 \\
  0 & \Omega_2 & \dots & 0 \\
  \vdots & \vdots & \ddots & \vdots \\
  0 & 0 & \dots & \Omega_k
  \end{pmatrix}
  $$
  
  - We compare three **standard** models for the $\Omega$ matrix in the next slides
  
<!--   
     - **Proper** CAR  [@PCAR]
     
     - **Leroux Proper** CAR [@Leroux]
     
     - Weighted [@BYM2] **Besag-York-Mollié** model [@BYM]
     
     
 
| Model | $\Omega$ Matrix | Parameter $\theta$ | $\theta = 0$ | $\theta = 1$ |
|-------|------------------|--------------------|--------------|--------------|
| PCAR  | $(I_k \otimes D - A \otimes W)^{-1}$ | $\alpha$ | Independent | ICAR |
| LCAR  | $[\Lambda \otimes L + (I_k - \Lambda) \otimes I_n]^{-1}$ | $\lambda$ | IID | ICAR |
| BYM   | $\Phi \otimes L + (I_k - \Phi) \otimes I_n$ | $\phi$ | IID | ICAR |
-->

 



## Models (2): Proper CAR (PCAR)

  - Generalises the ICAR allowing for a **proper** prior density with **nonsingular** precision [@PCAR]
  
  - Introduces a **spatial correlation** parameter $A := \mathrm{diag}(\alpha_1, ... \alpha_k)$, $\alpha_j \in [0,1] \, \forall j$
  
 
$$
\Omega =  (I_k \otimes D - A \otimes W)^{-1} 
$$
  
  - **Limit** cases: 
    - $\alpha_t = 0$: **independent** model ($\neq$ IID)
    - $\alpha_t = 1$: **ICAR**
    
```{r PCAR}

if(import_workspace){
  load("WS/cav_PMMCAR_inla_unif.RData")
  load("WS/cav_PMMCAR_inla_pc.RData")
} else {
  
 cav_PMMCAR_inla_unif <- inla(
  N_ACC ~  0+ Y_2021 + Y_2022 + Y_2023 + Y_2024 +
    TEP_th + ELI + PGR + UIS + ELL + PDI + ER+ 
    f(ID, model = inla.PMMCAR.model(k = 4, W = W_con, df = 8, PC = F)),
  offset = log(nn), control.inla = list(stupid.search = F),
  family = "poisson", data =dd, safe = F,
  num.threads = 1, control.compute = list(
    internal.opt = F, cpo = F, waic = T, config = F), 
  verbose = F)



cav_PMMCAR_inla_pc_strict  <- inla(
  N_ACC ~  0+ Y_2021 + Y_2022 + Y_2023 + Y_2024 +
    TEP_th + ELI + PGR + UIS + ELL + PDI + ER+ 
    f(ID, model = inla.PMMCAR.model(k = 4, W = W_con, df = 8, PC = T, alpha=0.9, U = 0.6)),
  offset = log(nn),
  family = "poisson", data =dd,
  num.threads = 1, control.compute = list(
    internal.opt = F, cpo = T, waic = T, config = F), 
  verbose = F)

}

```

    
## Models (3): Leroux proper CAR (LCAR)

  - Also generalises the ICAR allowing for a **proper** density
  
  - Introduces a **precision mixing** parameter $\Lambda := \mathrm{diag}(\lambda_1, ... \lambda_k)$, yet with $\lambda_j \in [0,1] \, \forall j$ [@Leroux]

$$
\Omega_j = \left(\Lambda \otimes L + (I_k - \Lambda)  
\right)
$$
  - $L$ = graph **Laplacian** matrix, i.e. $L = D-W$

  - Limit cases: 
    - $\lambda_t = 0$: IID model  
    - $\lambda_t = 1$: ICAR  
    
## Models (4): Besag-York-Mollié (BYM)

  - Actually a **reparametrisation** of the original BYM [@BYM], proposed by [@BYM2]

$$
Z = U \Phi^\frac{1}{2} M + V (I_k-\Phi^\frac{1}{2}) M
$$
  - $\Phi$: **variance** mixing parameter
  
  - $U \sim \mathcal{N}_{kn} \left(0, I_k \otimes L_S^{+} \right)$: independent ICAR (limit case for $\Phi = I_k$) $\rightarrow$ **spatial dependence**, where $L_S$: **scaled** Laplacian [@BYM2]
  
   - $V \sim \mathcal{N}_{kn} (0, I_{kn})$: std. IID field (limit case for $\Phi = 0$) $\rightarrow$ **noise**
 
 $$
 \therefore \Omega = \Phi \otimes L_S^+ + 
 (I_k - \Phi) \otimes I_n
 $$
 
## Multivariate PC-prior

  - The parameters $A$, $\Lambda$ and $\Phi$ are usually assigned a **Uniform** prior
  
  - A more **principle-based** approach is using **PC-priors**
    
    - This was already done by Rieber et Al. (2016) for the **univariate** BYM
  
  - Question: can we apply this approach in the **multivariate** setting, and also for **PCAR** and **LCAR** models?
  
  - Caveat: deriving **analytically** a PC-prior for **multivariate** parameters is hardly possible [@PC], [@MPC]
  
    $\longrightarrow$ workaround: **Sequential** derivation
  
## A Sequential approach for the PC-prior  
  
  - Let $\theta_j$ denote either $\alpha_j$, $\lambda_j$, or $\phi_j$ for $j = 1, \dots, k$
  
  - At each **step** $j$, we test the **flexible** model with $\theta_j > 0$, against the **base** model with $\theta_j = 0$, all other parameters being **unchanged**
  
  - Then, the **joint** prior simply comes from the chain rule: 
  
  $$\pi(\theta) = \pi (\theta_1) \pi(\theta_2 \mid \theta_1) \dots \pi(\theta_k \mid \theta_1, \dots, \theta_{k-1})$$
  
  - Provided that 
  
  $$
  \begin{align*}
  \pi(\theta_j \mid \theta_1, \dots, \theta_{j-1}) = \\ =\pi(\theta_j \mid \theta_1, \dots, \theta_{j-1}, \theta_{j+1}=\dots=\theta_k=0)
  \end{align*}
  $$
  
  
  
  
<style>
slides > slide { overflow: scroll; }
slides > slide:not(.nobackground):after {
  content: '';
}
</style>
## Cited works
  
  