---
title: "CAV_explorative"


output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(magrittr)
library(sf)
```

```{r input, echo = FALSE, message = FALSE, warning = FALSE, output = FALSE}
library(magrittr)
load("Distanze_Puglia/dist_short.RData")  # Distances from ISTAT file. Had to convert to RData 
# since original CSVs are almost impossible to handle

CAV_report_2022 <- readxl::read_excel("input_excel/cav_2022_report_20250120.xlsx", 
                                      sheet = "OR_PRO_COM") # Summary of the accesses report
# Foggia/Cerignola has been manually imputed to the closest municipality among the two!!!!

# Only the requests took charge of (AVOID DUPLICATES)
CAV_mun_22 <- CAV_report_2022 %>% dplyr::filter(.data$ESITO_ACCESSO == "presa in carico") %>% #
  dplyr::rename(PRO_COM = .data$PRO_COM_Residenza_Domicilio) %>% 
  dplyr::group_by(.data$PRO_COM) %>% 
  dplyr::summarise(N_ACC = dplyr::n(),
                   comune = stringr::str_to_title(.data$Comune_Residenza_Domicilio[1L])) %>% 
  dplyr::ungroup()
    
load("Shp.RData") # Shapefile of Apulian municipalities on 2022 jan 1st (cut some unnecessary fields)

# From old file passed by the Professor on Jan 4th:
popolazione <- read.csv("comuniperclassieta.csv",sep=";") # preso da Puglia opendata, ma forse si può fare di meglio
pop_f <- popolazione[popolazione$Eta>14,c(3,4,6)] # prendo donne con età >14
## ATTENZIONE: Aquarica del Capo si è fuso con Presicce
pop_f$Comune[pop_f$Comune=="Acquarica del Capo"] <- "Presicce"
pp <- tapply(pop_f$Femmine,pop_f$Comune,sum) # calcolo popolazione femminile >14 nei comuni pugliesi
qq <- names(pp)
qq[c(1,2,5)] <- c("Secli","Nardo","Patu") # problema con lettere accentate
pop_f_15 <- data.frame(COMUNE=toupper(qq), nn=as.vector(pp)) # df popolazione (nomi in maiuscolo)
rm(pp,qq)
pop <- pop_f_15[order(pop_f_15$COMUNE),] # attribuisco a pop COMUNE in d

dd <- Shp[order(Shp$COMUNE),]
# NOW this is not very elegant. Still, municipalities ordering
# is equal among the two files (pop and Shp), hence it is safe to merge them this way:
dd$nn <- pop$nn
dd <- dd %>% dplyr::left_join(CAV_mun_22,by = "PRO_COM") # here we merge with the excel file
dd$N_ACC[is.na(dd$N_ACC)] <- 0 # Absent records are counts == 0, not missing ones. Hence impute to zero.

dd$F_ACC <- dd$N_ACC/dd$nn # Access rate (from old file) 
dd <- sf::st_as_sf(dd) # I don't know if this is still necessary

```

```{r distances, echo = FALSE, message = FALSE, warning = FALSE, output = FALSE}


OR_DEST_Dettaglio <- readxl::read_excel("input_excel/OR_DEST_Dettaglio.xlsx") # Exact distance

# Manually made list of municipalities hosting a support center.
# We added Capurso, removed Triggiano, added San Severo:
munWcav <- munWcav <- c (71020,71024,71051,72004,72006,72011,72014,
                         72019,72021,72029,72031,72033,72035,73013,
                         73027,74001,74009,75018,75029,75035,75059,
                         110001,110002,110009) 


load("Distanze_Puglia/dists_th.RData") # Minimum distances from municipalities with a support center.
# This was generated with R but took a couple of minutes to end the loop, hence we exported the output to dist_th.RData

# Distance lists to be joined:
dist_cav_0 <- dist_short %>% dplyr::filter(.data$OR_DEST %in% dists_th$OR_DEST)
dist_cav_1 <- dist_short %>% dplyr::filter(.data$OR_DEST %in% OR_DEST_Dettaglio$OR_DEST)

# Average exact distance
Cav_dist_det <- OR_DEST_Dettaglio %>% dplyr::left_join(dist_cav_1, by = "OR_DEST") %>% 
  dplyr::filter(!is.na(.data$OR_PROCOM)) %>% 
  dplyr::rename(TEP_det = TEP_TOT, PRO_COM = .data$PRO_COM_Residenza_Domicilio) %>% 
  dplyr::select(.data$PRO_COM, .data$TEP_det)   #, .data$KM_TOT, .data$TTP_TOT

# Merged distances
Cav_dist <- Cav_dist_det %>% dplyr::group_by(.data$PRO_COM) %>% 
  dplyr::summarise(TEP_avg = mean(.data$TEP_det)) %>% 
  dplyr::ungroup() %>% 
  dplyr::right_join(dists_th, by = "PRO_COM")

# TEP_avg = average travel time between origin and exact destination.
# TEP_th = minimum distance
Cav_dist$TEP_avg[which(is.na(Cav_dist$TEP_avg))] <- 
  Cav_dist$TEP_th[which(is.na(Cav_dist$TEP_avg))]

# Tremiti islands. We need removing them since they're singletones 
# and mess up spatial structure. Zero accesses are reported by the way. Also distance is pretty outlying I guess.
suppressWarnings({
  singletons <- which(unlist(lapply(spdep::poly2nb(dd), function(x) x[1L] == 0)))
})

# Data frame we need to work on; scaled covariates
dd_con <- dd[-singletons, ] %>% 
  dplyr::left_join(Cav_dist, by = "PRO_COM") %>% 
  dplyr::mutate(TEP_th = as.vector(scale(.data$TEP_th)))%>% 
  dplyr::mutate(TEP_avg = as.vector(scale(.data$TEP_avg)))

# Neighbourhood matrix
nb_con <- spdep::poly2nb(dd_con)
W_con <- spdep::nb2mat(nb_con, style = "B")
rownames(W_con) <- colnames(W_con) <- dd_con$PRO_COM

# not needed anymore
#dd_con$N_ACC[which(is.na(dd_con$N_ACC))] <- 0
#dd_con$F_ACC[which(is.na(dd_con$F_ACC))] <- 0

dd_con$ID <- c(1:nrow(dd_con))


```



## Data
The dataset employed regards the counts of accesses to gender-based violence support centers in the Apulia region by residence municipality of the women victims of violence during 2022. 

Here, we only take into account the violence reports which support centers actually take charge of, at the risk of underestimating the number of gender-based violence cases.
This choice is driven by the need of avoiding duplicated records, since e.g. it may happen that a support center redirects a victim to another support center. 

In order to avoid singletons in the spatial structure of the dataset, we removed the Tremiti Islands from the list of municipalities included ($0$ accesses to support centers in 2022).

Therefore, the municipality-level dataset in scope consists of $256$ observations. 

We can only take into account the accesses to support centers for which the origin municipality of victims is reported. Therefore, the total count of accesses in scope is $2244$.

Here, we plot the log-access rate per residence municipality, i.e. the logarithm of the ratio between access counts and female population. Blank areas correspond to municipalities from which zero women accessed support centers ($82$ municipalities).


```{r Accesses plot, echo = FALSE, warning = FALSE, message = FALSE, fig.height = 3}
dd_con %>% 
  dplyr::mutate(rate = log(.data$N_ACC) - log(.data$nn)) %>% 
  ggplot2::ggplot() +
  ggplot2::geom_sf(ggplot2::aes(fill = .data$rate))+
  ggplot2::labs("Log incidence ratio") +
  ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1) +
  ggplot2::theme_classic()
  

```


On a preliminary stance, we are interested in evaluating the effect of the distance of support centers from residence municipalities of victims. For a generic residence municipality $i \in [1, 256]$ this distance is defined $d_i$ and is measured by road travel time in minutes.

#### Measuring distance

We employ two alternative definitions of $d_i$.
\begin{itemize}
\item $d_i^{(T)}$ is the theoretical distance, i.e. distance of municipality $i$ from the municipality hosting the support center competent for municipality $i$. 

For instance, the support center designated for the municipality of Adelfia (province of Bari, $3$rd municipality in the dataset) is located in Triggiano (BA). Then, $d_{3}^{(T)}$ denotes the travel time between Adelfia and Triggiano ($17$ minutes). 

Theoretical distance is available for all municipalities as long as a support center can be directly mapped to a municipality. 

\item $d_i^{(A)}$ Average distance between origin and actual destination (shelter) municipalities. 
\textbf{Warning: possible sensitive information. To be kept in \textit{inter nos} if the dataset is sensitive.}
Maintaining the example above, among the $7$ women resident in Adelfia, some turned to the center in Adelfia, and some other to the centers of Bari and Polignano a Mare. Therefore $d_{3}^{(A)}$ is the average travel time between Adelfia and these three municipalities ($35$ minutes).

Destination municipalities cannot be unambiguously determined for one case, which in the input dataset is labelled as "Foggia/Cerignola". In this case, we assigned the destination municipality to the one closer to the origin municipality of victims. 

For the $63$ municipalities from which no violence has been reported, the destination municipality has been imputed as the "designed" one, hence the $d^{(A)} = d^{(T)}$ in these cases.

\end{itemize}

## OLS regression

We regress the counts of accesses $y$ to support centers on the distance from the former using the two definitions provided above. Both covariates are scaled to zero mean an unit variance. 

\begin{equation}
\frac{y_i}{P_i} \mid \eta_i \sim \mathrm{Poisson}(e^{\eta_i}) \quad \text{where} \quad
\eta_i = \beta_0 + \beta d_i  
\label{eq:glm}
\end{equation}

Where $P_i$ is the female population of municipality $i$, and $d_i$ can be either $d_i^{(T)}$ or $d_i^{(A)}$.

```{r glms, echo = FALSE}
m_glm_th <- glm(N_ACC ~ 1 + TEP_th, family = "poisson",
                offset = log(nn), data = dd_con)
m_glm_avg <- glm(N_ACC ~ 1 + TEP_avg, family = "poisson",
                offset = log(nn), data = dd_con)
```


For what concerns the theorical distance, we find evidence for negative association
```{r glm th}
summary(m_glm_th)
```

The sign of the association is the same for the average actual distance, though the effect is slightly smaller in size.
```{r glm avg}

summary(m_glm_avg)
```

We plot the log-residuals $\varepsilon$ of the regression model in equation \ref{eq:glm}, defined as $\varepsilon := \ln y_i - \ln P_i - \ln \hat{y}_i$ being $\hat{y}_i$ the fitted value. Explanatory variable is theorical distance.


```{r glm residuals, echo = FALSE, fig.height = 3, fig.cap = "Log-residuals of glm regression using theorical distance as explanatory variable"}


resids_glm_th <- log(dd_con$N_ACC) - log(m_glm_th$fitted.values) - log(dd_con$nn)

dd_con %>% 
  dplyr::mutate(log_resids = resids_glm_th) %>% 
  ggplot2::ggplot() +
  ggplot2::geom_sf(ggplot2::aes(fill = .data$log_resids))+
  ggplot2::labs("blank") +
  ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1) +
  ggplot2::theme_classic()

# Problem: cannot apply Moran test to infinite values!
# Hence we need to only test autocorrelation across nonzero records.
# This strongly limits the relevance of the test, if I have a better idea I'll implememnt it.
nonzero <- which(dd_con$N_ACC > 0)

spdep::set.ZeroPolicyOption(TRUE)
suppressWarnings(nb_nonzero <- spdep::poly2nb(dd_con[nonzero, ]))

nonzero_singletons <- which(unlist(lapply(nb_nonzero, function(X) X[1L]==0)))
nonzero_con <- nonzero[-nonzero_singletons]
nb_con_nonzero <- spdep::poly2nb(dd_con[nonzero_con, ])
```

Residuals may exhibit spatial structure. To assess it, we employ the Moran and Geary tests. Since 

Please notice that log-residuals only take finite values across the $175$ municipalities whose female citizens have reported at least on case of violence in 2022.

Additionally, this set of municipalities includes $2$ singletons, which we remove to assess the value of the Moran and Geary statistics. Thus, we have defined the indexes set `nonzero_con` as the set of municipalities from which at leas one case of gender-based violence has been reported, \textit{and} which have at least one neighbouring municipalities from which at least one case of gender-based violence was reported. 

```{r moran residuals}
spdep::moran.test(resids_glm_th[nonzero_con],
                  listw = spdep::nb2listw(nb_con_nonzero))
spdep::geary.test(resids_glm_th[nonzero_con],
                  listw = spdep::nb2listw(nb_con_nonzero))

```

In both cases, we find evidence for spatial autocorrelation. However, we must stress out this result does not refer to all the regional territory, but only to a subset of all municipalities ($173$ over $257$)




## Spatial regression

Based on the autocorrelation evidence, though it has only been assessed for a subset of all municipalities, we try implementing a simple spatial model, say the intrinsic autoregressive:
\begin{equation}
\eta_i = \beta_0 + \beta d_i + z_i 
\label{eq:mspat}
\end{equation}

Where 
\begin{equation}
z_i \mid z_{-i} \sim N \left( \sum_{j=1}^n \frac{w_{ij}}{d_i} z_j \,, \frac{\sigma^2}{d_i}\right)
\label{eq:icar_loc}
\end{equation}
Here $w_{ij}$ is a generic element of the neighbourhood matrix of Apulia's municipalities, tanking value $1$ if two municipalities $i$ and $j$ are neighbours and zero if either $i$ and $j$ are not neighbours or $i = j$; $d_i$ is the number of neighbours of municipality $i$, and $\sigma^2$ is the scale parameter of the spatial effect. $n=256$ and the remainder of the model follows the same notation as eq. \ref{eq:glm}.

On a first stance, we will let the Laplace Approximation approximate posterior distributions of the quantities of interest (instead of e.g. relying on MCMC)

```{r inla nosp, echo = FALSE, message = FALSE, warning = FALSE}

library(INLA)
cav_nosp_INLA_th <- inla(
  N_ACC ~ 1 + TEP_th,
  family = "poisson", offset = log(nn), data =dd_con,
  num.threads = 1, control.compute = list(internal.opt = F, cpo = T, waic = T), 
  inla.mode = "classic", control.inla = list(strategy = "laplace"),
  verbose = F)
```

We set a PC-prior on the random effect to avoid overfitting. 
The `f()` argument sets the prior model on the spatial latent effect. Arguments `num.threads` and `internal.opt` are used for reproducibility. We use a PC-prior with rate parameter $\lambda = 1.5$, such that $\mathrm{Prob}(\sigma>\lambda) = 0.01$
```{r inla mod, message = FALSE, warning = FALSE}

cav_icar_INLA_th <- inla(
  N_ACC ~ 1 + TEP_th + f(ID, model = "besag", graph = W_con,
                         scale.model = T, prior = "pc.prec", param = c(1.5, 0.01)),
  family = "poisson", offset = log(nn), data =dd_con,
  num.threads = 1, control.compute = list(internal.opt = F, cpo = T, waic = T), 
  inla.mode = "classic", control.inla = list(strategy = "laplace"),
  verbose = F) # better
```

We compare the spatial and the nonspatial model (for coparability it has been re-run with R-INLA) through the Watanabe-Akaike information criterion
```{r waic}
cav_nosp_INLA_th$waic$waic # Higher WAIC
cav_nosp_INLA_th$waic$p.eff # Low complexity

cav_icar_INLA_th$waic$waic # Lower WAIC
cav_icar_INLA_th$waic$p.eff # High complexity

```

Which suggests us the spatial model is preferable; model complexity increases (`p.eff` denotes the number of free/unconstrained parameters) but is still outweighter by better fitting. 
 Here we show some summaries for the spatial model:
```{r summary fixed}
cav_icar_INLA_th$summary.fixed
```
 
We still see distance from the closest support center has a negative effect on the accesses. A tentative interpretation we may draw from this result is that the distance from support centers may tend to discourage women from reporting gender-based violence, and the occurrence of gender-based violence may be underestimated in areas distant from support centers. 

The spatial effect is to be interpreted as the spatial variation not explained by model components. Here we show the posterior summaries of the marginal variance parameter ($\sigma^2$) of the spatial effect
```{r summary hyperpar}
inla.zmarginal(inla.tmarginal(
  fun = function(X) 1/X,
  marginal = cav_icar_INLA_th$marginals.hyperpar[[1]]))
```

And we plot the posterior expectations of the latent effect.





```{r zhat, fig.height = 3, message = F, warning = F, echo = F, fig.cap = "Posterior expectation of the spatial latent effect"}
dd_con %>% 
  dplyr::mutate(zhat = cav_icar_INLA_th$summary.random$ID$mean) %>% 
  ggplot2::ggplot() +
  ggplot2::geom_sf(ggplot2::aes(fill = .data$zhat))+
  ggplot2::labs("blank") +
  ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1) +
  ggplot2::theme_classic()
```
 
Now, the intrinsic autoregressive model is relatively simple to interpret and to implement, 
while also requiring the minimum number of additional parameter (either the scale or the precision).
The drawback, however, is that we assume a spatial autocorrelation coefficient equal to 1.
When the autocorrelation is weak, setting an ICAR prior may be a form of misspecification.

A generalisation of this model is the PCAR (proper CAR), which introduces an autocorrelation parameter $\alpha$:


\begin{equation}
z_i \mid z_{-i} \sim N \left( \sum_{j=1}^n \alpha \frac{w_{ij}}{d_i} z_j \,, \frac{\sigma^2}{d_i}\right)
\label{eq:icar_loc}
\end{equation}

Although it is not readily implemented in `R-INLA` (the `"besagproper"` effect is actually the Leroux model!) we may base the R code on the `INLAMSM` package:
```{r pcar definition}
inla.rgeneric.PCAR.model <- 
  function (cmd = c("graph", "Q", "mu", "initial", "log.norm.const", 
                                              "log.prior", "quit"), theta = NULL) {
  interpret.theta <- function() {
    alpha <- 1/(1 + exp(-theta[1L])) # alpha modelled in logit scale
    mprec <- sapply(theta[2L], function(x) {
      exp(x)
    })
    PREC <- mprec
    return(list(alpha = alpha, mprec = mprec, PREC = PREC))
  }
  graph <- function() {
    G <- Matrix::Diagonal(nrow(W), 1) + W
    return(G)
  }
  Q <- function() {
    param <- interpret.theta()
    Q <- param$PREC * 
      (Matrix::Diagonal(nrow(W), apply(W, 1, sum)) - param$alpha * W)
    return(Q)
  }
  mu <- function() {
    return(numeric(0))
  }
  log.norm.const <- function() {
    val <- numeric(0)
    return(val)
  }
  log.prior <- function() {
    param <- interpret.theta()
    val <- -theta[1L] - 2 * log(1 + exp(-theta[1L]))
    # # PC prior
    val <- val + log(lambda/2) - theta[2L]/2 - (lambda * exp(-theta[2L]/2))
    # # Gamma(1, 5e-5), default prior:
    #val <- val + dgamma(exp(theta[2L]), shape = 1, rate = 5e-5, log = T) + theta[2L]
    # # Uniform prior on the standard deviation
    #val <- val - sum(theta[2L])/2 - k * log(2)
    return(val)
  }
  initial <- function() {
    return(c(0, 4))
  }
  quit <- function() {
    return(invisible())
  }
  if (as.integer(R.version$major) > 3) {
    if (!length(theta)) 
      theta = initial()
  }
  else {
    if (is.null(theta)) {
      theta <- initial()
    }
  }
  val <- do.call(match.arg(cmd), args = list())
  return(val)
}
PCAR.model <- function(...) INLA::inla.rgeneric.define(inla.rgeneric.PCAR.model, ...)
```
Then the model is run
```{r pcar run, message = FALSE, output = FALSE}
cav_pcar_INLA_th <- inla(N_ACC ~ 1 + TEP_th + f(ID, model = PCAR.model(W = W_con, k = 1, lambda = 1.5)),
                         family = "poisson", offset = log(nn), data =dd_con,
                         num.threads = 1, control.compute = 
                           list(internal.opt = F, cpo = T, waic = T), 
                         inla.mode = "classic", control.inla = list(strategy = "laplace"),
                         control.predictor = list(compute = T),
                         verbose = T) 


```

We compare the WAICs of the two spatial models

```{r waic pcar}
cav_icar_INLA_th$waic$waic # Higher WAIC
cav_icar_INLA_th$waic$p.eff 

cav_pcar_INLA_th$waic$waic # Lower WAIC
cav_pcar_INLA_th$waic$p.eff # Complexity is not even raised

```

The lower WAIC suggests us that the PCAR, which does not even appear to be more complex although the additional parameter $\alpha$.
We show the posterior summaries of the regression coefficients

```{r pcar summary fix}
cav_pcar_INLA_th$summary.fixed
```

however, the spatial autocorrelation does not appear particularly strong. Additionally, the credible interval appears uncannily wide:
```{r alfa, echo = FALSE}
expit <- function (X){
  return(1/(1 + exp(-X)))
}

inla.zmarginal(inla.tmarginal(fun = expit,
                              marginal = cav_pcar_INLA_th$marginals.hyperpar[[1]]))
```




