---
title: "Exploratory analysis of accesses to support centers for gender-based violence
  in Apulia"
output:
  pdf_document: default
  word_document: default
  html_document:
    df_print: paged
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning= FALSE)
par(mar = c(2,2,1,1))
library(magrittr)
library(sf)
library(INLA)
#if(!rlang::is_installed("pscl")) install.packages("pscl")
```

## Data

The dataset employed regards the counts of accesses to gender-based violence support centers in the Apulia region by residence municipality of the women victims of violence in 2021-2024. `R` codes to generate the dataset are in the R script [posted here](https://github.com/lcef97/CAV_Puglia/blob/main/CAV_full.R) which this report is based on. 

Here, we only take into account the violence reports which support centers actually take charge of, at the risk of underestimating the counts of gender-based violence cases.
This choice is driven by the need of avoiding duplicated records, since e.g. it may happen that a support center redirects a victim to another support center. 
```{r input mute, echo = FALSE, message = FALSE, warning = FALSE, output = FALSE}

## Input ----------------------------------------------------------------------#
 
load("input/CAV_input_mun_2021.RData")
load("input/CAV_input_mun_2022.RData")
load("input/CAV_input_mun_2023.RData")
load("input/CAV_input_mun_2024.RData")

CAV_mun_21 <- CAV_mun_21 %>% dplyr::rename(N_ACC_2021 = .data$N_ACC)
CAV_mun_22 <- CAV_mun_22 %>% dplyr::rename(N_ACC_2022 = .data$N_ACC)
CAV_mun_23 <- CAV_mun_23 %>% dplyr::rename(N_ACC_2023 = .data$N_ACC)
CAV_mun_24 <- CAV_mun_24 %>% dplyr::rename(N_ACC_2024 = .data$N_ACC)

load("input/Shp.RData")

#'  Function to extract numeric digits from a strings vector (needed to filter age):
nn_extract <- function(string){
  nn <- gregexpr("([0-9])", string)
  ls.out <- regmatches(as.list(string), nn)
  res <- unlist(lapply(ls.out, function(x) as.numeric(paste(x, collapse = ""))))  
  return(res)
}

Popolazione_Puglia_2021 <- readr::read_csv("input/Popolazione_Puglia_2021.csv") %>% 
  dplyr::select(.data$ITTER107, .data$Territorio, .data$SEXISTAT1, .data$ETA1, .data$Value) %>% 
  dplyr::filter(.data$ETA1 != "TOTAL") %>% 
  dplyr::mutate(ETA1 = nn_extract(.data$ETA1)) %>% 
  dplyr::mutate(ITTER107 = as.numeric(.data$ITTER107))

Popolazione_Puglia_2022 <- readr::read_csv("input/Popolazione_Puglia_2022.csv") %>% 
  dplyr::select(.data$ITTER107, .data$Territorio, .data$SEXISTAT1, .data$ETA1, .data$Value) %>% 
  dplyr::filter(.data$ETA1 != "TOTAL") %>% 
  dplyr::mutate(ETA1 = nn_extract(.data$ETA1)) %>% 
  dplyr::mutate(ITTER107 = as.numeric(.data$ITTER107))

Popolazione_Puglia_2023 <- readr::read_csv("input/Popolazione_Puglia_2023.csv") %>% 
  dplyr::select(.data$ITTER107, .data$Territorio, .data$SEXISTAT1, .data$ETA1, .data$Value) %>% 
  dplyr::filter(.data$ETA1 != "TOTAL") %>% 
  dplyr::mutate(ETA1 = nn_extract(.data$ETA1)) %>% 
  dplyr::mutate(ITTER107 = as.numeric(.data$ITTER107))

Popolazione_Puglia_2024 <- readr::read_csv("input/Popolazione_Puglia_2024.csv",
                                           quote = "")  %>% 
  dplyr::filter(.data$AGE != "TOTAL") %>% 
  dplyr::mutate(ETA1 = nn_extract(.data$AGE)) %>% 
  dplyr::mutate(ITTER107 = as.numeric(.data$REF_AREA)) %>% 
  dplyr::rename(SEXISTAT1 = .data$SEX, Value = .data$Osservazione)%>% 
  dplyr::select(.data$ITTER107, .data$SEXISTAT1, .data$ETA1, .data$Value)


Pop_f_15 <- Popolazione_Puglia_2021 %>% 
  dplyr::left_join(Popolazione_Puglia_2022,
                   by = c("ITTER107", "Territorio", "SEXISTAT1", "ETA1")) %>% 
  dplyr::left_join(Popolazione_Puglia_2023,
                   by = c("ITTER107", "Territorio", "SEXISTAT1", "ETA1")) %>% 
  dplyr::left_join(Popolazione_Puglia_2024,
                   by =  c("ITTER107",  "SEXISTAT1", "ETA1"))

names(Pop_f_15) <-  c("PRO_COM", "Comune", "Sesso", "Eta", 
                      "Popolazione_21", "Popolazione_22", "Popolazione_23", "Popolazione_24")

Pop_f_15 <- Pop_f_15 %>% dplyr::filter(.data$Sesso == 2) %>% 
  dplyr::filter(.data$Eta > 14) %>% 
  dplyr::group_by(.data$PRO_COM, .data$Comune) %>% 
  dplyr::summarise(nn_2021 = sum(.data$Popolazione_21),
                   nn_2022 = sum(.data$Popolazione_22),
                   nn_2023 = sum(.data$Popolazione_23),
                   nn_2024 = sum(.data$Popolazione_24)) %>%
  dplyr::ungroup()


# Tremiti Islands are a singleton --> need to remove them to perform spatial analysis
suppressWarnings({
  singletons <- Shp$PRO_COM[which(
    unlist(lapply(spdep::poly2nb(Shp),
                  function(x) x[1L] == 0)))]
})

load("input/dists_th_22.RData")
load("input/dists_th_23.RData")
load("input/dists_th_24.RData")
names(dists_th_22)[2] <- names(dists_th_23)[2] <- names(dists_th_24)[2] <- "TEP_th"
distances <- rbind(dists_th_22, dists_th_22, dists_th_23, dists_th_24) %>% 
  dplyr::mutate(Year = c(rep("2021", nrow(dists_th_22)),
                         rep("2022", nrow(dists_th_22)),
                         rep("2023", nrow(dists_th_23)),
                         rep("2024", nrow(dists_th_24))) )


Shp_con <- dplyr::filter(Shp, !.data$PRO_COM %in% singletons)
n <- nrow(Shp_con)


dd <- Shp_con %>% dplyr::left_join(Pop_f_15[, -2], by = "PRO_COM") %>% 
  dplyr::left_join(dplyr::select(CAV_mun_21, -.data$comune),by = "PRO_COM") %>% 
  dplyr::left_join(dplyr::select(CAV_mun_22, -.data$comune),by = "PRO_COM") %>% 
  dplyr::left_join(dplyr::select(CAV_mun_23, -.data$comune),by = "PRO_COM") %>% 
  dplyr::left_join(dplyr::select(CAV_mun_24, -.data$comune),by = "PRO_COM") %>% 
  tidyr::pivot_longer(cols = tidyselect::starts_with("nn_") | 
                        tidyselect::starts_with("N_ACC_"),
                      names_to = c(".value", "Year"),
                      names_pattern = "(nn|N_ACC)_(\\d+)" ) %>% 
  dplyr::left_join(dplyr::select(Indicators, -.data$Comune), by = "PRO_COM") %>% 
  dplyr::arrange(.data$Year, .data$PRO_COM)  %>% 
  dplyr::left_join(distances, by = c("PRO_COM", "Year")) %>% 
  dplyr::mutate(CAV = as.numeric(.data$TEP_th == 0)) %>% 
  dplyr::mutate(Y_2021 = as.numeric(.data$Year == "2021")) %>% 
  dplyr::mutate(Y_2022 = as.numeric(.data$Year == "2022")) %>% 
  dplyr::mutate(Y_2023 = as.numeric(.data$Year == "2023")) %>% 
  dplyr::mutate(Y_2024 = as.numeric(.data$Year == "2024")) %>% 
  dplyr::mutate(TEP_th = as.vector(scale(.data$TEP_th))) %>% 
  dplyr::mutate(AES = as.vector(scale(.data$AES))) %>% 
  dplyr::mutate(MFI = as.vector(scale(.data$MFI)))  %>% 
  dplyr::mutate(PDI = as.vector(scale(.data$PDI)))  %>% 
  dplyr::mutate(ELL = as.vector(scale(.data$ELL)))  %>% 
  dplyr::mutate(ER = as.vector(scale(.data$ER)))  %>% 
  dplyr::mutate(PGR = as.vector(scale(.data$PGR)))  %>% 
  dplyr::mutate(UIS = as.vector(scale(.data$UIS)))  %>% 
  dplyr::mutate(ELI = as.vector(scale(.data$ELI)))  %>% 
  dplyr::select(-.data$Year) %>% 
  dplyr::mutate(ID = c(1:nrow(.))) %>% 
  dplyr::mutate(Area = as.numeric(as.factor(.data$PRO_COM)))



# Municipalities from which no woman reported violence --> count == 0
dd$N_ACC[is.na(dd$N_ACC)] <- 0

# "access ratio"
dd$LN_ACC <- log(dd$N_ACC/dd$nn)

#' neighbours list ------------------------------------------------------------#
nb_con <- spdep::poly2nb(dd[c(1:n), ])

#' neighbouring/adjacency matrix ----------------------------------------------#
W_con <- spdep::nb2mat(nb_con, style = "B")
rownames(W_con) <- colnames(W_con) <- dd$PRO_COM[c(1:n)]

#' Laplacian matrix -----------------------------------------------------------#
D_con <- Matrix::Diagonal(x=apply(W_con, MARGIN=1, FUN=function(x) sum(x)), n=n)
Lapl_con <- D_con - W_con
V_con <- eigen(Lapl_con)$vectors

constr <- INLA:::inla.bym.constr.internal(
  Q = Lapl_con, adjust.for.con.comp = T)
A_constr <- kronecker(Matrix::Diagonal(n=4,x=1), constr$constr$A)

#'  Necessary to constrain the BYM model --------------------------------------#
constr.BYM <- list(
  A = cbind(Matrix::Matrix(0, nrow = nrow(A_constr), ncol = ncol(A_constr)), A_constr),
  e=c(0,0,0,0) )





zhat_plot <- function(mod){
  n <- nrow(mod$.args$data)
  rr <- range(mod$summary.random$ID$mean[c(1:n)])
  
  plot_map <- purrr::map(unique(dd$Year), function (t){
  dd %>% dplyr::mutate(zhat = mod$summary.random$ID$mean[c(1:n)]) %>% 
    dplyr::filter(as.numeric(.data$Year) == t) %>% 
    ggplot2::ggplot() +
    ggplot2::geom_sf(ggplot2::aes(fill = .data$zhat))+
    ggplot2::labs(title = paste("Year:", 2020+ t), 
                  fill = expression(E * "[" * z * "]")) +
    ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
    ggplot2::theme_classic()
  })

do.call(gridExtra::grid.arrange, c(plot_map, nrow = 2, ncol = 2))

}

yhat_plot <- function(mod ){
  
  yhat <- round(mod$summary.fitted.values$mean, 0)

  rr <- c(0, max(yhat))
  
  plot_map <- purrr::map(unique(dd$Year), function (t){
    dd %>% dplyr::mutate(yhat = yhat) %>% 
      dplyr::filter(as.numeric(.data$Year) == t) %>% 
      ggplot2::ggplot() +
      ggplot2::geom_sf(ggplot2::aes(fill = .data$yhat)) +
      ggplot2::labs(title = paste("Year:", 2020+ t), 
                    fill = expression(E * "[" * hat(y) * "]") )+
      ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
      ggplot2::theme_classic()
  })
  do.call(gridExtra::grid.arrange, c(plot_map, nrow = 2, ncol = 2))
}

etahat_plot <- function(mod, predictor = FALSE){
  
  etahat <- mod$summary.linear.predictor$mean
  
  rr <- range(etahat)
  
  plot_map <- purrr::map(unique(dd$Year), function (t){
    dd %>% 
      dplyr::mutate(etahat = etahat) %>% 
      dplyr::filter(as.numeric(.data$Year) == t) %>% 
      ggplot2::ggplot() +
      ggplot2::geom_sf(ggplot2::aes(fill =  .data$etahat )) +
      ggplot2::labs(title = paste("Year:", 2020+ t),
                    fill = expression(E * "[" * eta * "]")) + 
      ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
      ggplot2::theme_classic()
    })

do.call(gridExtra::grid.arrange, c(plot_map, nrow = 2, ncol = 2))

}


```


In order to avoid singletons, i.e. municipalities with no neighbours, in the spatial structure of the dataset, the Tremiti Islands need to be removed from the list of municipalities included ($0$ accesses recorded so far).

Therefore, the municipality-level dataset in scope consists of $256$ areas. 

We can only take into account the accesses to support centers for which the origin municipality of victims is reported; therefore the total count of accesses in scope is $1477$, $1516$, $1822$ and $1778$for the reference years respectively:


Here, we plot the log-access rate per residence municipality, i.e. the logarithm of the ratio between access counts and female population. Blank areas correspond to municipalities from which zero women accessed support centers ($82$ municipalities).

```{r Log accesses plot, echo = FALSE, warning = FALSE, message = FALSE, fig.cap = "Log-access rate" }


ggy21 <- ggplot2::ggplot() +
  ggplot2::geom_sf(data = dplyr::filter(dd, .data$Y_2021 == 1), 
                   ggplot2::aes(fill = .data$LN_ACC))+
  ggplot2::labs(fill = "Log-accesses, 2021")+
  ggplot2::scale_fill_viridis_c(na.value = "white",
                                direction = -1,
                                limits = c(-9.5, -4.5))+
  ggplot2::theme_classic()

ggy22 <- ggplot2::ggplot() +
  ggplot2::geom_sf(data = dplyr::filter(dd, .data$Y_2022 == 1), 
                   ggplot2::aes(fill = .data$LN_ACC))+
  ggplot2::labs(fill = "Log-accesses, 2022")+
  ggplot2::scale_fill_viridis_c(na.value = "white",
                                direction = -1,
                                limits = c(-9.5, -4.5))+
  ggplot2::theme_classic()

ggy23 <- ggplot2::ggplot() +
  ggplot2::geom_sf(data = dplyr::filter(dd, .data$Y_2023 == 1), 
                   ggplot2::aes(fill = .data$LN_ACC))+
  ggplot2::labs(fill = "Log-accesses, 2023")+
  ggplot2::scale_fill_viridis_c(na.value = "white",
                                direction = -1,
                                limits = c(-9.5, -4.5))+
  ggplot2::theme_classic()

ggy24 <- ggplot2::ggplot() +
  ggplot2::geom_sf(data = dplyr::filter(dd, .data$Y_2024 == 1), 
                   ggplot2::aes(fill = .data$LN_ACC))+
  ggplot2::labs(fill = "Log-accesses, 2024")+
  ggplot2::scale_fill_viridis_c(na.value = "white",
                                direction = -1,
                                limits = c(-9.5, -4.5))+
  ggplot2::theme_classic()

gridExtra::grid.arrange(ggy21, ggy22, ggy23, ggy24, nrow = 2, ncol = 2)

```

## Covariates

Our target is explaining the number of accesses to support centers, $y$, defined at the municipality level, on the basis of a set of candidate known variables. $y$ is modelled with simple Poisson regression.

We have at disposal a number of candidate explanatory variables, which include the distance of a municipality from the closest support center and a set of variables measuring social vulnerability under different dimensions; these latter covariates are provided by [the ISTAT](https://www.istat.it/comunicato-stampa/indice-di-fragilita-comunale-ifc/) and are among the components of the Municipality Frailty Index (MFI). A more detailed description of MFI components is in [this excel metadata file](https://github.com/lcef97/CAV_Puglia/blob/main/Metadata/Indice_composito_fragilita_PUGLIA_2021.xlsx).

All covariates are quantitative variables and to ease model interpretation are scaled to have null mean and unit variance.

  -  $\mathrm{TEP\_th}$, i.e. the distance of each municipality from the closest municipality hosting a support center. Distance is measured by road travel time in minutes (acronym TEP stays for Tempo Effettivo di Percorrenza, i.e. Actual Travel Time). Since to the best of our knowledge the list of active support centers changed between 2022 and 2023, we employ the list of centers active until 2022 for 2021-2022 data, and the list of centers active in 2023 for 2023 data.

  -  $\mathrm{AES}$, the distance from the closest infrastructural pole, always measured in travel time. Infrastructural poles are defined as municipalities or clusters of neighbouring municipalities provided with a certain endowment in health, education and transport infrastructure (more details can be found, e.g., [here](https://www.istat.it/comunicato-stampa/la-geografia-delle-aree-interne-nel-2020-vasti-territori-tra-potenzialita-e-debolezze/)).
  -  $\mathrm{MFI}$, i.e. the decile of municipality frailty index.
  -  $\mathrm{PDI}$, i.e. the dependency index, i.e. population either $\leq 20$ or $\geq 65$ years over population in $[20 - 64]$ years.
  -  $\mathrm{ELL}$, i.e. the proportion of people aged $[25-54]$ with low education.
  -  $\mathrm{ERR}$, i.e. employment rate among people aged $[20-64]$.
  -  $\mathrm{PGR}$, i.e. population growth rate with respect to 2011.
  -  $\mathrm{UIS}$, i.e. the ventile of the density of local units of industry and services (where density is defined as the ratio between the counts of industrial units and population).
  -  $\mathrm{ELI}$, i.e. the ventile of employees in low productivity local units by sector for industry and services.

First, we visualise the correlations among these explanatory variables:

```{r correls, echo = F, warning = F, fig.height = 3, fig.cap = "Correlations in explanatory variables"}



glm_all_X <- glm(N_ACC ~ 1 + TEP_th + MFI + AES + PDI + ELL + ER +
                   PGR + UIS + ELI + offset(log(nn)),
                 data = dd, family = "poisson")
# model matrix
X <- model.matrix(glm_all_X)



ggplot2::ggplot(data = reshape2::melt(cor(X[,-1]))) +
  ggplot2::geom_tile(ggplot2::aes(
    x = .data$Var2, y = .data$Var1, fill = .data$value), color = "black", size = 3) +
  ggplot2::geom_text(ggplot2::aes(
    x = .data$Var2, y = .data$Var1, label = round(.data$value, 2))) +
  ggplot2::scale_fill_gradient2(
    low = "blue", mid = "white", high = "red", midpoint = 0) +
  ggplot2::theme_minimal()
```

We see the correlation between the two distances is very high ($0.72$), and so is the correlation between the fragility index decile and the density of productive units. 

In the first case, we drop the distance from the nearest infrastructural pole. In the latter we drop `MFI`, which is a combination of all covariates except for `TEP_th`, and is a weakly informative choice.


## Nonspatial regression

We regress the counts of accesses $y$ to support centers on the aforementioned explanatory variables. To interpret regression coefficients in an easier way, all covariates are scaled to zero mean an unit variance. 

\begin{equation}
y_{it} \mid \eta_{it} \sim \mathrm{Poisson}(E_{it} \, e^{\eta_{it}}) \quad \text{where} \quad
\eta_{it} = X_{it}^{\top} \alpha
\label{eq:glm}
\end{equation}

Where $X$ are the covariates defined earlier, $\alpha$ are covariate effects, and $E_{it}$ is the female population aged $\geq 15$ in municipality $i$ and year $t$.

To gain more insight on the role of all explanatory variables we show the posterior summaries of the regression model; the posterior distribution is approximated with the INLA [@INLA].
 

```{r glm results, warning = FALSE, message = FALSE, echo = FALSE, results = "asis"}


cav_glm <- glm(N_ACC ~ 0 + Y_2021 + Y_2022 + Y_2023 + Y_2024 + TEP_th + PDI + ELL + ER +
                   PGR + UIS + ELI + offset(log(nn)),
                 data = dd, family = "poisson")

alphas.glm <- data.frame(
  Mean = summary(cav_glm)$coefficients[,1],
  Sd = summary(cav_glm)$coefficients[,2]) %>% 
  dplyr::mutate(Effect = c("Int_2021", "Int_2022", "Int_2023", "INT_2024",
                           rownames(summary(cav_glm)$coefficients)[-c(1,2,3,4)])) %>% 
  dplyr::relocate(.data$Effect, .before = 1)

#print(xtable::xtable(alphas.glm, num.digits = 3), include.rowname = FALSE)
```


```{r INLA nosp, warning = FALSE, echo = FALSE, message = FALSE, results = "asis"}
cav_nosp_inla <- inla(
  N_ACC ~0 + Y_2021 + Y_2022 +Y_2023 +Y_2024 +
    TEP_th + ELI + PGR + UIS + ELL + PDI + ER  ,
  offset = log(nn),
  family = "poisson", data =dd,
  num.threads = 1, control.compute = list(internal.opt = F, cpo = T, waic = T, config = T), 
  verbose = T)

alphas.nosp.inla <-  cav_nosp_inla$summary.fixed %>% 
  dplyr::select(c(1,2,3,5)) %>% 
  dplyr::mutate(Effect = c("Int_2021", "Int_2022", "Int_2023", "Int_2024",
                           rownames(cav_nosp_inla$summary.fixed)[-c(1:4)])) %>% 
  dplyr::relocate(.data$Effect, .before = 1) %>%  
  dplyr::rename(Mean = .data$mean, Sd = .data$sd)
  

print(xtable::xtable(alphas.nosp.inla, digits = 3), include.rowname  = F)

```



  - `TEP_th_22`: The distance from the closest support center appears to play an important role. The easiest interpretation is that the physical distance represents a barrier to violence reporting. This is quite intuitive if we think of the material dynamics of reporting gender-based violence: one could reasonably expect violent men to prevent their partners to take a long rout and come out to report the violence suffered.
  
  - `ELI`: The (ventile of the distribution of the) share of employees in low productivity economic units is a clear indicator of (relative) economic underdevelopment. The most naive interpretation would be that in underdeveloped areas reporting gender violence is somewhat harder than in developed ones.

  - `PGR`: The association with population growth rate does not appear to be significantly different from zero.
  
  <!-- is harder to interpret. This association is most likely influenced by several demographic instrumental variables we are not keeping into account and would indeed deserve a more dedicated focus. --> 
  
  - `UIS`: The (ventile of the distribution of the) density of production units does not appear to have a significantly $\neq 0$ association with VAW reporting.

  - `ELL`: The association with the proportion of people with low educational level has negative sign and is high in absolute value. The interpretation seems quite easy: cultural development, in general, would encourage reporting violence.
  
  - `PDI`: The association with population dependency index is negative, and its interpretation is ambiguous as well since the proportion of old or very young people can be read as a limiting factor both for VAW incidence and reporting.
  
  - `ER`: The association with employment rate is very strong and bears negative sign for 2021 and 2023 data.

## Spatial regression

#### Exploratory analysis of residuals
We plot the log-residuals $\varepsilon$ of the nonspatial regression models, defined as $\varepsilon := \ln y_{it} - \ln \hat{y}_{it}$ being $\hat{y}_{it}$ the fitted value.

```{r glm residuals, echo = FALSE, warnings = FALSE, message = FALSE, output = FALSE}
#L_block <- kronecker(diag(1, 3), Lapl_con)
constr <- INLA:::inla.bym.constr.internal(Lapl_con, adjust.for.con.comp = T)
A_constr <- kronecker(Matrix::Diagonal(x=1, n=4), constr$constr$A)
resids_glm <- log(dd$N_ACC) - log(cav_glm$fitted.values)

rr <- range(resids_glm[which(is.finite(resids_glm))])

ggr21 <- dd %>% 
  dplyr::mutate(log_resids_2021 = resids_glm) %>% 
  dplyr::filter(.data$Y_2021 == 1) %>% 
  ggplot2::ggplot() +
  ggplot2::geom_sf(ggplot2::aes(fill = .data$log_resids_2021))+
  ggplot2::labs("blank") +
  ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
  ggplot2::theme_classic()

ggr22 <- dd %>% 
  dplyr::mutate(log_resids_2022 = resids_glm) %>% 
  dplyr::filter(.data$Y_2022 == 1) %>% 
  ggplot2::ggplot() +
  ggplot2::geom_sf(ggplot2::aes(fill = .data$log_resids_2022))+
  ggplot2::labs("blank") +
  ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
  ggplot2::theme_classic()

ggr23 <- dd  %>% 
  dplyr::mutate(log_resids_2023 = resids_glm) %>% 
  dplyr::filter(.data$Y_2023 == 1) %>% 
  ggplot2::ggplot() +
  ggplot2::geom_sf(ggplot2::aes(fill = .data$log_resids_2023))+
  ggplot2::labs("blank") +
  ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
  ggplot2::theme_classic()

ggr24 <- dd  %>% 
  dplyr::mutate(log_resids_2024 = resids_glm) %>% 
  dplyr::filter(.data$Y_2024 == 1) %>% 
  ggplot2::ggplot() +
  ggplot2::geom_sf(ggplot2::aes(fill = .data$log_resids_2024))+
  ggplot2::labs("blank") +
  ggplot2::scale_fill_viridis_c(na.value = "white", direction = -1, limits = rr) +
  ggplot2::theme_classic()

#' Problem: cannot apply Moran test to infinite values!
#' Hence we need to only test autocorrelation across nonzero records.
#' This strongly limits the relevance of the test, if I have a better idea I'll implememnt it.
nonzero_21 <- which(dd$N_ACC > 0 & dd$Y_2021 == 1)
nonzero_22 <- which(dd$N_ACC > 0 & dd$Y_2022 == 1)
nonzero_23 <- which(dd$N_ACC > 0 & dd$Y_2023 == 1)
nonzero_24 <- which(dd$N_ACC > 0 & dd$Y_2024 == 1)


spdep::set.ZeroPolicyOption(TRUE)
suppressWarnings(nb_nonzero_21 <- spdep::poly2nb(dd[nonzero_21, ]))
suppressWarnings(nb_nonzero_22 <- spdep::poly2nb(dd[nonzero_22, ]))
suppressWarnings(nb_nonzero_23 <- spdep::poly2nb(dd[nonzero_23, ]))
suppressWarnings(nb_nonzero_24 <- spdep::poly2nb(dd[nonzero_24, ]))


nonzero_singletons_21 <- which(unlist(lapply(nb_nonzero_21, function(X) X[1L]==0)))
nonzero_singletons_22 <- which(unlist(lapply(nb_nonzero_22, function(X) X[1L]==0)))
nonzero_singletons_23 <- which(unlist(lapply(nb_nonzero_23, function(X) X[1L]==0)))
nonzero_singletons_24 <- which(unlist(lapply(nb_nonzero_24, function(X) X[1L]==0)))


if(length(nonzero_singletons_21 > 0)){
  nonzero_con_21 <- nonzero_21[-nonzero_singletons_21]
  } else nonzero_con_21 <- nonzero_21
nonzero_con_22 <- nonzero_22[-nonzero_singletons_22]
nonzero_con_23 <- nonzero_23[-nonzero_singletons_23]
if(length(nonzero_singletons_24 > 0)){
  nonzero_con_24 <- nonzero_24[-nonzero_singletons_24]
  } else nonzero_con_24 <- nonzero_24

nb_con_nonzero_21 <- spdep::poly2nb(dd[nonzero_con_21, ])
nb_con_nonzero_22 <- spdep::poly2nb(dd[nonzero_con_22, ])
nb_con_nonzero_23 <- spdep::poly2nb(dd[nonzero_con_23, ])
nb_con_nonzero_24 <- spdep::poly2nb(dd[nonzero_con_24, ])



```
```{r Log residuals, echo=FALSE, fig.cap = "Log-residuals in GLM regression", message=FALSE, warning=FALSE}

gridExtra::grid.arrange(ggr21, ggr22, ggr23, ggr24, nrow = 2, ncol = 2)


```


Residuals may exhibit spatial structure. To assess it, we employ the Moran and Geary tests. Since 

Please notice that log-residuals only take finite values across the municipalities whose female citizens have reported at least one case of violence.


